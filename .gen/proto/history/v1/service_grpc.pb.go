// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package historyv1

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// HistoryAPIClient is the client API for HistoryAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HistoryAPIClient interface {
	// StartWorkflowExecution starts a new long running workflow instance.  It will create the instance with
	// 'WorkflowExecutionStarted' event in history and also schedule the first DecisionTask for the worker to make the
	// first decision for this instance.  It will return 'WorkflowExecutionAlreadyStartedError', if an instance already
	// exists with same workflowId.
	StartWorkflowExecution(ctx context.Context, in *StartWorkflowExecutionRequest, opts ...grpc.CallOption) (*StartWorkflowExecutionResponse, error)
	// SignalWorkflowExecution is used to send a signal event to running workflow execution.  This results in
	// WorkflowExecutionSignaled event recorded in the history and a decision task being created for the execution.
	SignalWorkflowExecution(ctx context.Context, in *SignalWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWorkflowExecutionResponse, error)
	// SignalWithStartWorkflowExecution is used to ensure sending a signal event to a workflow execution.
	// If workflow is running, this results in WorkflowExecutionSignaled event recorded in the history
	// and a decision task being created for the execution.
	// If workflow is not running or not found, it will first try start workflow with given WorkflowIDReusePolicy,
	// and record WorkflowExecutionStarted and WorkflowExecutionSignaled event in case of success.
	// It will return `WorkflowExecutionAlreadyStartedError` if start workflow failed with given policy.
	SignalWithStartWorkflowExecution(ctx context.Context, in *SignalWithStartWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWithStartWorkflowExecutionResponse, error)
	// ResetWorkflowExecution reset an existing workflow execution by a firstEventID of a existing event batch
	// in the history and immediately terminating the current execution instance.
	// After reset, the history will grow from nextFirstEventID.
	ResetWorkflowExecution(ctx context.Context, in *ResetWorkflowExecutionRequest, opts ...grpc.CallOption) (*ResetWorkflowExecutionResponse, error)
	// TerminateWorkflowExecution terminates an existing workflow execution by recording WorkflowExecutionTerminated event
	// in the history and immediately terminating the execution instance.
	TerminateWorkflowExecution(ctx context.Context, in *TerminateWorkflowExecutionRequest, opts ...grpc.CallOption) (*TerminateWorkflowExecutionResponse, error)
	// DescribeWorkflowExecution returns information about the specified workflow execution.
	DescribeWorkflowExecution(ctx context.Context, in *DescribeWorkflowExecutionRequest, opts ...grpc.CallOption) (*DescribeWorkflowExecutionResponse, error)
	// QueryWorkflow returns query result for a specified workflow execution.
	QueryWorkflow(ctx context.Context, in *QueryWorkflowRequest, opts ...grpc.CallOption) (*QueryWorkflowResponse, error)
	// Reset the sticky tasklist related information in mutable state of a given workflow.
	// Things cleared are:
	// 1. StickyTaskList
	// 2. StickyScheduleToStartTimeout
	// 3. ClientLibraryVersion
	// 4. ClientFeatureVersion
	// 5. ClientImpl
	ResetStickyTaskList(ctx context.Context, in *ResetStickyTaskListRequest, opts ...grpc.CallOption) (*ResetStickyTaskListResponse, error)
	// Returns the information from mutable state of workflow execution.
	// It fails with 'EntityNotExistError' if specified workflow execution in unknown to the service.
	// It returns CurrentBranchChangedError if the workflow version branch has changed.
	GetMutableState(ctx context.Context, in *GetMutableStateRequest, opts ...grpc.CallOption) (*GetMutableStateResponse, error)
	// Returns the information from mutable state of workflow execution.
	// It fails with 'EntityNotExistError' if specified workflow execution in unknown to the service.
	// It returns CurrentBranchChangedError if the workflow version branch has changed.
	PollMutableState(ctx context.Context, in *PollMutableStateRequest, opts ...grpc.CallOption) (*PollMutableStateResponse, error)
	// RecordDecisionTaskStarted is called by the MatchingService before it hands a decision task to the application worker in response to
	// a PollForDecisionTask call. It records in the history the event that the decision task has started. It will return 'EventAlreadyStartedError',
	// if the workflow's execution history already includes a record of the event starting.
	RecordDecisionTaskStarted(ctx context.Context, in *RecordDecisionTaskStartedRequest, opts ...grpc.CallOption) (*RecordDecisionTaskStartedResponse, error)
	// RespondDecisionTaskCompleted is called by application worker to complete a DecisionTask handed as a result of
	// 'PollForDecisionTask' API call.  Completing a DecisionTask will result in new events for the workflow execution and
	// potentially new ActivityTask being created for corresponding decisions.  It will also create a DecisionTaskCompleted
	// event in the history for that session.  Use the 'taskToken' provided as response of PollForDecisionTask API call
	// for completing the DecisionTask.
	RespondDecisionTaskCompleted(ctx context.Context, in *RespondDecisionTaskCompletedRequest, opts ...grpc.CallOption) (*RespondDecisionTaskCompletedResponse, error)
	// RespondDecisionTaskFailed is called by application worker to indicate failure.  This results in
	// DecisionTaskFailedEvent written to the history and a new DecisionTask created.  This API can be used by client to
	// either clear sticky tasklist or report ny panics during DecisionTask processing.
	RespondDecisionTaskFailed(ctx context.Context, in *RespondDecisionTaskFailedRequest, opts ...grpc.CallOption) (*RespondDecisionTaskFailedResponse, error)
	// RecordActivityTaskStarted is called by the MatchingService before it hands a decision task to the application worker in response to
	// a PollForActivityTask call. It records in the history the event that the decision task has started. It will return 'EventAlreadyStartedError',
	// if the workflow's execution history already includes a record of the event starting.
	RecordActivityTaskStarted(ctx context.Context, in *RecordActivityTaskStartedRequest, opts ...grpc.CallOption) (*RecordActivityTaskStartedResponse, error)
	// RespondActivityTaskCompleted is called by application worker when it is done processing an ActivityTask.  It will
	// result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
	// created for the workflow so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskCompleted(ctx context.Context, in *RespondActivityTaskCompletedRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedResponse, error)
	// RespondActivityTaskFailed is called by application worker when it is done processing an ActivityTask.  It will
	// result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskFailed(ctx context.Context, in *RespondActivityTaskFailedRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedResponse, error)
	// RespondActivityTaskCanceled is called by application worker when it is successfully canceled an ActivityTask.  It will
	// result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskCanceled(ctx context.Context, in *RespondActivityTaskCanceledRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledResponse, error)
	// RecordActivityTaskHeartbeat is called by application worker while it is processing an ActivityTask.  If worker fails
	// to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timed out and
	// 'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
	// fail with 'EntityNotExistsError' in such situations.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for heart beating.
	RecordActivityTaskHeartbeat(ctx context.Context, in *RecordActivityTaskHeartbeatRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatResponse, error)
	// RequestCancelWorkflowExecution is called by application worker when it wants to request cancellation of a workflow instance.
	// It will result in a new 'WorkflowExecutionCancelRequested' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made. It fails with 'EntityNotExistsError' if the workflow is not valid
	// anymore due to completion or doesn't exist.
	RequestCancelWorkflowExecution(ctx context.Context, in *RequestCancelWorkflowExecutionRequest, opts ...grpc.CallOption) (*RequestCancelWorkflowExecutionResponse, error)
	// RemoveSignalMutableState is used to remove a signal request ID that was previously recorded.  This is currently
	// used to clean execution info when signal decision finished.
	RemoveSignalMutableState(ctx context.Context, in *RemoveSignalMutableStateRequest, opts ...grpc.CallOption) (*RemoveSignalMutableStateResponse, error)
	// ScheduleDecisionTask is used for creating a decision task for already started workflow execution.  This is mainly
	// used by transfer queue processor during the processing of StartChildWorkflowExecution task, where it first starts
	// child execution without creating the decision task and then calls this API after updating the mutable state of
	// parent execution.
	ScheduleDecisionTask(ctx context.Context, in *ScheduleDecisionTaskRequest, opts ...grpc.CallOption) (*ScheduleDecisionTaskResponse, error)
	// RecordChildExecutionCompleted is used for reporting the completion of child workflow execution to parent.
	// This is mainly called by transfer queue processor during the processing of DeleteExecution task.
	RecordChildExecutionCompleted(ctx context.Context, in *RecordChildExecutionCompletedRequest, opts ...grpc.CallOption) (*RecordChildExecutionCompletedResponse, error)
	ReplicateEventsV2(ctx context.Context, in *ReplicateEventsV2Request, opts ...grpc.CallOption) (*ReplicateEventsV2Response, error)
	// SyncShardStatus sync the status between shards.
	SyncShardStatus(ctx context.Context, in *SyncShardStatusRequest, opts ...grpc.CallOption) (*SyncShardStatusResponse, error)
	// SyncActivity sync the activity status.
	SyncActivity(ctx context.Context, in *SyncActivityRequest, opts ...grpc.CallOption) (*SyncActivityResponse, error)
	// DescribeMutableState returns information about the internal states of workflow mutable state.
	DescribeMutableState(ctx context.Context, in *DescribeMutableStateRequest, opts ...grpc.CallOption) (*DescribeMutableStateResponse, error)
	// DescribeHistoryHost returns information about the internal states of a history host.
	DescribeHistoryHost(ctx context.Context, in *DescribeHistoryHostRequest, opts ...grpc.CallOption) (*DescribeHistoryHostResponse, error)
	// CloseShard close the shard.
	CloseShard(ctx context.Context, in *CloseShardRequest, opts ...grpc.CallOption) (*CloseShardResponse, error)
	// RemoveTask remove task based on type, task_id, shard_id.
	RemoveTask(ctx context.Context, in *RemoveTaskRequest, opts ...grpc.CallOption) (*RemoveTaskResponse, error)
	// ResetQueue reset processing queue state based on cluster name and type.
	ResetQueue(ctx context.Context, in *ResetQueueRequest, opts ...grpc.CallOption) (*ResetQueueResponse, error)
	// DescribeQueue return queue states based on cluster name and type.
	DescribeQueue(ctx context.Context, in *DescribeQueueRequest, opts ...grpc.CallOption) (*DescribeQueueResponse, error)
	// GetReplicationMessages return replication messages based on the read level.
	GetReplicationMessages(ctx context.Context, in *GetReplicationMessagesRequest, opts ...grpc.CallOption) (*GetReplicationMessagesResponse, error)
	// GetDLQReplicationMessages return replication messages based on DLQ info.
	GetDLQReplicationMessages(ctx context.Context, in *GetDLQReplicationMessagesRequest, opts ...grpc.CallOption) (*GetDLQReplicationMessagesResponse, error)
	// ReapplyEvents applies stale events to the current workflow and current run.
	ReapplyEvents(ctx context.Context, in *ReapplyEventsRequest, opts ...grpc.CallOption) (*ReapplyEventsResponse, error)
	// RefreshWorkflowTasks refreshes all tasks of a workflow.
	RefreshWorkflowTasks(ctx context.Context, in *RefreshWorkflowTasksRequest, opts ...grpc.CallOption) (*RefreshWorkflowTasksResponse, error)
	// ReadDLQMessages returns messages from DLQ.
	ReadDLQMessages(ctx context.Context, in *ReadDLQMessagesRequest, opts ...grpc.CallOption) (*ReadDLQMessagesResponse, error)
	// PurgeDLQMessages purges messages from DLQ.
	PurgeDLQMessages(ctx context.Context, in *PurgeDLQMessagesRequest, opts ...grpc.CallOption) (*PurgeDLQMessagesResponse, error)
	// MergeDLQMessages merges messages from DLQ.
	MergeDLQMessages(ctx context.Context, in *MergeDLQMessagesRequest, opts ...grpc.CallOption) (*MergeDLQMessagesResponse, error)
	// NotifyFailoverMarkers sends failover marker to the failover coordinator.
	NotifyFailoverMarkers(ctx context.Context, in *NotifyFailoverMarkersRequest, opts ...grpc.CallOption) (*NotifyFailoverMarkersResponse, error)
}

type historyAPIClient struct {
	cc grpc.ClientConnInterface
}

func NewHistoryAPIClient(cc grpc.ClientConnInterface) HistoryAPIClient {
	return &historyAPIClient{cc}
}

func (c *historyAPIClient) StartWorkflowExecution(ctx context.Context, in *StartWorkflowExecutionRequest, opts ...grpc.CallOption) (*StartWorkflowExecutionResponse, error) {
	out := new(StartWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/StartWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) SignalWorkflowExecution(ctx context.Context, in *SignalWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWorkflowExecutionResponse, error) {
	out := new(SignalWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/SignalWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) SignalWithStartWorkflowExecution(ctx context.Context, in *SignalWithStartWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWithStartWorkflowExecutionResponse, error) {
	out := new(SignalWithStartWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/SignalWithStartWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) ResetWorkflowExecution(ctx context.Context, in *ResetWorkflowExecutionRequest, opts ...grpc.CallOption) (*ResetWorkflowExecutionResponse, error) {
	out := new(ResetWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/ResetWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) TerminateWorkflowExecution(ctx context.Context, in *TerminateWorkflowExecutionRequest, opts ...grpc.CallOption) (*TerminateWorkflowExecutionResponse, error) {
	out := new(TerminateWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/TerminateWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) DescribeWorkflowExecution(ctx context.Context, in *DescribeWorkflowExecutionRequest, opts ...grpc.CallOption) (*DescribeWorkflowExecutionResponse, error) {
	out := new(DescribeWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/DescribeWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) QueryWorkflow(ctx context.Context, in *QueryWorkflowRequest, opts ...grpc.CallOption) (*QueryWorkflowResponse, error) {
	out := new(QueryWorkflowResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/QueryWorkflow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) ResetStickyTaskList(ctx context.Context, in *ResetStickyTaskListRequest, opts ...grpc.CallOption) (*ResetStickyTaskListResponse, error) {
	out := new(ResetStickyTaskListResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/ResetStickyTaskList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) GetMutableState(ctx context.Context, in *GetMutableStateRequest, opts ...grpc.CallOption) (*GetMutableStateResponse, error) {
	out := new(GetMutableStateResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/GetMutableState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) PollMutableState(ctx context.Context, in *PollMutableStateRequest, opts ...grpc.CallOption) (*PollMutableStateResponse, error) {
	out := new(PollMutableStateResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/PollMutableState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) RecordDecisionTaskStarted(ctx context.Context, in *RecordDecisionTaskStartedRequest, opts ...grpc.CallOption) (*RecordDecisionTaskStartedResponse, error) {
	out := new(RecordDecisionTaskStartedResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/RecordDecisionTaskStarted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) RespondDecisionTaskCompleted(ctx context.Context, in *RespondDecisionTaskCompletedRequest, opts ...grpc.CallOption) (*RespondDecisionTaskCompletedResponse, error) {
	out := new(RespondDecisionTaskCompletedResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/RespondDecisionTaskCompleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) RespondDecisionTaskFailed(ctx context.Context, in *RespondDecisionTaskFailedRequest, opts ...grpc.CallOption) (*RespondDecisionTaskFailedResponse, error) {
	out := new(RespondDecisionTaskFailedResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/RespondDecisionTaskFailed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) RecordActivityTaskStarted(ctx context.Context, in *RecordActivityTaskStartedRequest, opts ...grpc.CallOption) (*RecordActivityTaskStartedResponse, error) {
	out := new(RecordActivityTaskStartedResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/RecordActivityTaskStarted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) RespondActivityTaskCompleted(ctx context.Context, in *RespondActivityTaskCompletedRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedResponse, error) {
	out := new(RespondActivityTaskCompletedResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/RespondActivityTaskCompleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) RespondActivityTaskFailed(ctx context.Context, in *RespondActivityTaskFailedRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedResponse, error) {
	out := new(RespondActivityTaskFailedResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/RespondActivityTaskFailed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) RespondActivityTaskCanceled(ctx context.Context, in *RespondActivityTaskCanceledRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledResponse, error) {
	out := new(RespondActivityTaskCanceledResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/RespondActivityTaskCanceled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) RecordActivityTaskHeartbeat(ctx context.Context, in *RecordActivityTaskHeartbeatRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatResponse, error) {
	out := new(RecordActivityTaskHeartbeatResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/RecordActivityTaskHeartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) RequestCancelWorkflowExecution(ctx context.Context, in *RequestCancelWorkflowExecutionRequest, opts ...grpc.CallOption) (*RequestCancelWorkflowExecutionResponse, error) {
	out := new(RequestCancelWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/RequestCancelWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) RemoveSignalMutableState(ctx context.Context, in *RemoveSignalMutableStateRequest, opts ...grpc.CallOption) (*RemoveSignalMutableStateResponse, error) {
	out := new(RemoveSignalMutableStateResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/RemoveSignalMutableState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) ScheduleDecisionTask(ctx context.Context, in *ScheduleDecisionTaskRequest, opts ...grpc.CallOption) (*ScheduleDecisionTaskResponse, error) {
	out := new(ScheduleDecisionTaskResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/ScheduleDecisionTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) RecordChildExecutionCompleted(ctx context.Context, in *RecordChildExecutionCompletedRequest, opts ...grpc.CallOption) (*RecordChildExecutionCompletedResponse, error) {
	out := new(RecordChildExecutionCompletedResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/RecordChildExecutionCompleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) ReplicateEventsV2(ctx context.Context, in *ReplicateEventsV2Request, opts ...grpc.CallOption) (*ReplicateEventsV2Response, error) {
	out := new(ReplicateEventsV2Response)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/ReplicateEventsV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) SyncShardStatus(ctx context.Context, in *SyncShardStatusRequest, opts ...grpc.CallOption) (*SyncShardStatusResponse, error) {
	out := new(SyncShardStatusResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/SyncShardStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) SyncActivity(ctx context.Context, in *SyncActivityRequest, opts ...grpc.CallOption) (*SyncActivityResponse, error) {
	out := new(SyncActivityResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/SyncActivity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) DescribeMutableState(ctx context.Context, in *DescribeMutableStateRequest, opts ...grpc.CallOption) (*DescribeMutableStateResponse, error) {
	out := new(DescribeMutableStateResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/DescribeMutableState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) DescribeHistoryHost(ctx context.Context, in *DescribeHistoryHostRequest, opts ...grpc.CallOption) (*DescribeHistoryHostResponse, error) {
	out := new(DescribeHistoryHostResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/DescribeHistoryHost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) CloseShard(ctx context.Context, in *CloseShardRequest, opts ...grpc.CallOption) (*CloseShardResponse, error) {
	out := new(CloseShardResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/CloseShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) RemoveTask(ctx context.Context, in *RemoveTaskRequest, opts ...grpc.CallOption) (*RemoveTaskResponse, error) {
	out := new(RemoveTaskResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/RemoveTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) ResetQueue(ctx context.Context, in *ResetQueueRequest, opts ...grpc.CallOption) (*ResetQueueResponse, error) {
	out := new(ResetQueueResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/ResetQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) DescribeQueue(ctx context.Context, in *DescribeQueueRequest, opts ...grpc.CallOption) (*DescribeQueueResponse, error) {
	out := new(DescribeQueueResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/DescribeQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) GetReplicationMessages(ctx context.Context, in *GetReplicationMessagesRequest, opts ...grpc.CallOption) (*GetReplicationMessagesResponse, error) {
	out := new(GetReplicationMessagesResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/GetReplicationMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) GetDLQReplicationMessages(ctx context.Context, in *GetDLQReplicationMessagesRequest, opts ...grpc.CallOption) (*GetDLQReplicationMessagesResponse, error) {
	out := new(GetDLQReplicationMessagesResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/GetDLQReplicationMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) ReapplyEvents(ctx context.Context, in *ReapplyEventsRequest, opts ...grpc.CallOption) (*ReapplyEventsResponse, error) {
	out := new(ReapplyEventsResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/ReapplyEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) RefreshWorkflowTasks(ctx context.Context, in *RefreshWorkflowTasksRequest, opts ...grpc.CallOption) (*RefreshWorkflowTasksResponse, error) {
	out := new(RefreshWorkflowTasksResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/RefreshWorkflowTasks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) ReadDLQMessages(ctx context.Context, in *ReadDLQMessagesRequest, opts ...grpc.CallOption) (*ReadDLQMessagesResponse, error) {
	out := new(ReadDLQMessagesResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/ReadDLQMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) PurgeDLQMessages(ctx context.Context, in *PurgeDLQMessagesRequest, opts ...grpc.CallOption) (*PurgeDLQMessagesResponse, error) {
	out := new(PurgeDLQMessagesResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/PurgeDLQMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) MergeDLQMessages(ctx context.Context, in *MergeDLQMessagesRequest, opts ...grpc.CallOption) (*MergeDLQMessagesResponse, error) {
	out := new(MergeDLQMessagesResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/MergeDLQMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyAPIClient) NotifyFailoverMarkers(ctx context.Context, in *NotifyFailoverMarkersRequest, opts ...grpc.CallOption) (*NotifyFailoverMarkersResponse, error) {
	out := new(NotifyFailoverMarkersResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.history.v1.HistoryAPI/NotifyFailoverMarkers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HistoryAPIServer is the server API for HistoryAPI service.
// All implementations must embed UnimplementedHistoryAPIServer
// for forward compatibility
type HistoryAPIServer interface {
	// StartWorkflowExecution starts a new long running workflow instance.  It will create the instance with
	// 'WorkflowExecutionStarted' event in history and also schedule the first DecisionTask for the worker to make the
	// first decision for this instance.  It will return 'WorkflowExecutionAlreadyStartedError', if an instance already
	// exists with same workflowId.
	StartWorkflowExecution(context.Context, *StartWorkflowExecutionRequest) (*StartWorkflowExecutionResponse, error)
	// SignalWorkflowExecution is used to send a signal event to running workflow execution.  This results in
	// WorkflowExecutionSignaled event recorded in the history and a decision task being created for the execution.
	SignalWorkflowExecution(context.Context, *SignalWorkflowExecutionRequest) (*SignalWorkflowExecutionResponse, error)
	// SignalWithStartWorkflowExecution is used to ensure sending a signal event to a workflow execution.
	// If workflow is running, this results in WorkflowExecutionSignaled event recorded in the history
	// and a decision task being created for the execution.
	// If workflow is not running or not found, it will first try start workflow with given WorkflowIDReusePolicy,
	// and record WorkflowExecutionStarted and WorkflowExecutionSignaled event in case of success.
	// It will return `WorkflowExecutionAlreadyStartedError` if start workflow failed with given policy.
	SignalWithStartWorkflowExecution(context.Context, *SignalWithStartWorkflowExecutionRequest) (*SignalWithStartWorkflowExecutionResponse, error)
	// ResetWorkflowExecution reset an existing workflow execution by a firstEventID of a existing event batch
	// in the history and immediately terminating the current execution instance.
	// After reset, the history will grow from nextFirstEventID.
	ResetWorkflowExecution(context.Context, *ResetWorkflowExecutionRequest) (*ResetWorkflowExecutionResponse, error)
	// TerminateWorkflowExecution terminates an existing workflow execution by recording WorkflowExecutionTerminated event
	// in the history and immediately terminating the execution instance.
	TerminateWorkflowExecution(context.Context, *TerminateWorkflowExecutionRequest) (*TerminateWorkflowExecutionResponse, error)
	// DescribeWorkflowExecution returns information about the specified workflow execution.
	DescribeWorkflowExecution(context.Context, *DescribeWorkflowExecutionRequest) (*DescribeWorkflowExecutionResponse, error)
	// QueryWorkflow returns query result for a specified workflow execution.
	QueryWorkflow(context.Context, *QueryWorkflowRequest) (*QueryWorkflowResponse, error)
	// Reset the sticky tasklist related information in mutable state of a given workflow.
	// Things cleared are:
	// 1. StickyTaskList
	// 2. StickyScheduleToStartTimeout
	// 3. ClientLibraryVersion
	// 4. ClientFeatureVersion
	// 5. ClientImpl
	ResetStickyTaskList(context.Context, *ResetStickyTaskListRequest) (*ResetStickyTaskListResponse, error)
	// Returns the information from mutable state of workflow execution.
	// It fails with 'EntityNotExistError' if specified workflow execution in unknown to the service.
	// It returns CurrentBranchChangedError if the workflow version branch has changed.
	GetMutableState(context.Context, *GetMutableStateRequest) (*GetMutableStateResponse, error)
	// Returns the information from mutable state of workflow execution.
	// It fails with 'EntityNotExistError' if specified workflow execution in unknown to the service.
	// It returns CurrentBranchChangedError if the workflow version branch has changed.
	PollMutableState(context.Context, *PollMutableStateRequest) (*PollMutableStateResponse, error)
	// RecordDecisionTaskStarted is called by the MatchingService before it hands a decision task to the application worker in response to
	// a PollForDecisionTask call. It records in the history the event that the decision task has started. It will return 'EventAlreadyStartedError',
	// if the workflow's execution history already includes a record of the event starting.
	RecordDecisionTaskStarted(context.Context, *RecordDecisionTaskStartedRequest) (*RecordDecisionTaskStartedResponse, error)
	// RespondDecisionTaskCompleted is called by application worker to complete a DecisionTask handed as a result of
	// 'PollForDecisionTask' API call.  Completing a DecisionTask will result in new events for the workflow execution and
	// potentially new ActivityTask being created for corresponding decisions.  It will also create a DecisionTaskCompleted
	// event in the history for that session.  Use the 'taskToken' provided as response of PollForDecisionTask API call
	// for completing the DecisionTask.
	RespondDecisionTaskCompleted(context.Context, *RespondDecisionTaskCompletedRequest) (*RespondDecisionTaskCompletedResponse, error)
	// RespondDecisionTaskFailed is called by application worker to indicate failure.  This results in
	// DecisionTaskFailedEvent written to the history and a new DecisionTask created.  This API can be used by client to
	// either clear sticky tasklist or report ny panics during DecisionTask processing.
	RespondDecisionTaskFailed(context.Context, *RespondDecisionTaskFailedRequest) (*RespondDecisionTaskFailedResponse, error)
	// RecordActivityTaskStarted is called by the MatchingService before it hands a decision task to the application worker in response to
	// a PollForActivityTask call. It records in the history the event that the decision task has started. It will return 'EventAlreadyStartedError',
	// if the workflow's execution history already includes a record of the event starting.
	RecordActivityTaskStarted(context.Context, *RecordActivityTaskStartedRequest) (*RecordActivityTaskStartedResponse, error)
	// RespondActivityTaskCompleted is called by application worker when it is done processing an ActivityTask.  It will
	// result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
	// created for the workflow so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskCompleted(context.Context, *RespondActivityTaskCompletedRequest) (*RespondActivityTaskCompletedResponse, error)
	// RespondActivityTaskFailed is called by application worker when it is done processing an ActivityTask.  It will
	// result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskFailed(context.Context, *RespondActivityTaskFailedRequest) (*RespondActivityTaskFailedResponse, error)
	// RespondActivityTaskCanceled is called by application worker when it is successfully canceled an ActivityTask.  It will
	// result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskCanceled(context.Context, *RespondActivityTaskCanceledRequest) (*RespondActivityTaskCanceledResponse, error)
	// RecordActivityTaskHeartbeat is called by application worker while it is processing an ActivityTask.  If worker fails
	// to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timed out and
	// 'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
	// fail with 'EntityNotExistsError' in such situations.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for heart beating.
	RecordActivityTaskHeartbeat(context.Context, *RecordActivityTaskHeartbeatRequest) (*RecordActivityTaskHeartbeatResponse, error)
	// RequestCancelWorkflowExecution is called by application worker when it wants to request cancellation of a workflow instance.
	// It will result in a new 'WorkflowExecutionCancelRequested' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made. It fails with 'EntityNotExistsError' if the workflow is not valid
	// anymore due to completion or doesn't exist.
	RequestCancelWorkflowExecution(context.Context, *RequestCancelWorkflowExecutionRequest) (*RequestCancelWorkflowExecutionResponse, error)
	// RemoveSignalMutableState is used to remove a signal request ID that was previously recorded.  This is currently
	// used to clean execution info when signal decision finished.
	RemoveSignalMutableState(context.Context, *RemoveSignalMutableStateRequest) (*RemoveSignalMutableStateResponse, error)
	// ScheduleDecisionTask is used for creating a decision task for already started workflow execution.  This is mainly
	// used by transfer queue processor during the processing of StartChildWorkflowExecution task, where it first starts
	// child execution without creating the decision task and then calls this API after updating the mutable state of
	// parent execution.
	ScheduleDecisionTask(context.Context, *ScheduleDecisionTaskRequest) (*ScheduleDecisionTaskResponse, error)
	// RecordChildExecutionCompleted is used for reporting the completion of child workflow execution to parent.
	// This is mainly called by transfer queue processor during the processing of DeleteExecution task.
	RecordChildExecutionCompleted(context.Context, *RecordChildExecutionCompletedRequest) (*RecordChildExecutionCompletedResponse, error)
	ReplicateEventsV2(context.Context, *ReplicateEventsV2Request) (*ReplicateEventsV2Response, error)
	// SyncShardStatus sync the status between shards.
	SyncShardStatus(context.Context, *SyncShardStatusRequest) (*SyncShardStatusResponse, error)
	// SyncActivity sync the activity status.
	SyncActivity(context.Context, *SyncActivityRequest) (*SyncActivityResponse, error)
	// DescribeMutableState returns information about the internal states of workflow mutable state.
	DescribeMutableState(context.Context, *DescribeMutableStateRequest) (*DescribeMutableStateResponse, error)
	// DescribeHistoryHost returns information about the internal states of a history host.
	DescribeHistoryHost(context.Context, *DescribeHistoryHostRequest) (*DescribeHistoryHostResponse, error)
	// CloseShard close the shard.
	CloseShard(context.Context, *CloseShardRequest) (*CloseShardResponse, error)
	// RemoveTask remove task based on type, task_id, shard_id.
	RemoveTask(context.Context, *RemoveTaskRequest) (*RemoveTaskResponse, error)
	// ResetQueue reset processing queue state based on cluster name and type.
	ResetQueue(context.Context, *ResetQueueRequest) (*ResetQueueResponse, error)
	// DescribeQueue return queue states based on cluster name and type.
	DescribeQueue(context.Context, *DescribeQueueRequest) (*DescribeQueueResponse, error)
	// GetReplicationMessages return replication messages based on the read level.
	GetReplicationMessages(context.Context, *GetReplicationMessagesRequest) (*GetReplicationMessagesResponse, error)
	// GetDLQReplicationMessages return replication messages based on DLQ info.
	GetDLQReplicationMessages(context.Context, *GetDLQReplicationMessagesRequest) (*GetDLQReplicationMessagesResponse, error)
	// ReapplyEvents applies stale events to the current workflow and current run.
	ReapplyEvents(context.Context, *ReapplyEventsRequest) (*ReapplyEventsResponse, error)
	// RefreshWorkflowTasks refreshes all tasks of a workflow.
	RefreshWorkflowTasks(context.Context, *RefreshWorkflowTasksRequest) (*RefreshWorkflowTasksResponse, error)
	// ReadDLQMessages returns messages from DLQ.
	ReadDLQMessages(context.Context, *ReadDLQMessagesRequest) (*ReadDLQMessagesResponse, error)
	// PurgeDLQMessages purges messages from DLQ.
	PurgeDLQMessages(context.Context, *PurgeDLQMessagesRequest) (*PurgeDLQMessagesResponse, error)
	// MergeDLQMessages merges messages from DLQ.
	MergeDLQMessages(context.Context, *MergeDLQMessagesRequest) (*MergeDLQMessagesResponse, error)
	// NotifyFailoverMarkers sends failover marker to the failover coordinator.
	NotifyFailoverMarkers(context.Context, *NotifyFailoverMarkersRequest) (*NotifyFailoverMarkersResponse, error)
	mustEmbedUnimplementedHistoryAPIServer()
}

// UnimplementedHistoryAPIServer must be embedded to have forward compatible implementations.
type UnimplementedHistoryAPIServer struct {
}

func (UnimplementedHistoryAPIServer) StartWorkflowExecution(context.Context, *StartWorkflowExecutionRequest) (*StartWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWorkflowExecution not implemented")
}
func (UnimplementedHistoryAPIServer) SignalWorkflowExecution(context.Context, *SignalWorkflowExecutionRequest) (*SignalWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignalWorkflowExecution not implemented")
}
func (UnimplementedHistoryAPIServer) SignalWithStartWorkflowExecution(context.Context, *SignalWithStartWorkflowExecutionRequest) (*SignalWithStartWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignalWithStartWorkflowExecution not implemented")
}
func (UnimplementedHistoryAPIServer) ResetWorkflowExecution(context.Context, *ResetWorkflowExecutionRequest) (*ResetWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetWorkflowExecution not implemented")
}
func (UnimplementedHistoryAPIServer) TerminateWorkflowExecution(context.Context, *TerminateWorkflowExecutionRequest) (*TerminateWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateWorkflowExecution not implemented")
}
func (UnimplementedHistoryAPIServer) DescribeWorkflowExecution(context.Context, *DescribeWorkflowExecutionRequest) (*DescribeWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeWorkflowExecution not implemented")
}
func (UnimplementedHistoryAPIServer) QueryWorkflow(context.Context, *QueryWorkflowRequest) (*QueryWorkflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryWorkflow not implemented")
}
func (UnimplementedHistoryAPIServer) ResetStickyTaskList(context.Context, *ResetStickyTaskListRequest) (*ResetStickyTaskListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetStickyTaskList not implemented")
}
func (UnimplementedHistoryAPIServer) GetMutableState(context.Context, *GetMutableStateRequest) (*GetMutableStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMutableState not implemented")
}
func (UnimplementedHistoryAPIServer) PollMutableState(context.Context, *PollMutableStateRequest) (*PollMutableStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollMutableState not implemented")
}
func (UnimplementedHistoryAPIServer) RecordDecisionTaskStarted(context.Context, *RecordDecisionTaskStartedRequest) (*RecordDecisionTaskStartedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordDecisionTaskStarted not implemented")
}
func (UnimplementedHistoryAPIServer) RespondDecisionTaskCompleted(context.Context, *RespondDecisionTaskCompletedRequest) (*RespondDecisionTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondDecisionTaskCompleted not implemented")
}
func (UnimplementedHistoryAPIServer) RespondDecisionTaskFailed(context.Context, *RespondDecisionTaskFailedRequest) (*RespondDecisionTaskFailedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondDecisionTaskFailed not implemented")
}
func (UnimplementedHistoryAPIServer) RecordActivityTaskStarted(context.Context, *RecordActivityTaskStartedRequest) (*RecordActivityTaskStartedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordActivityTaskStarted not implemented")
}
func (UnimplementedHistoryAPIServer) RespondActivityTaskCompleted(context.Context, *RespondActivityTaskCompletedRequest) (*RespondActivityTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCompleted not implemented")
}
func (UnimplementedHistoryAPIServer) RespondActivityTaskFailed(context.Context, *RespondActivityTaskFailedRequest) (*RespondActivityTaskFailedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskFailed not implemented")
}
func (UnimplementedHistoryAPIServer) RespondActivityTaskCanceled(context.Context, *RespondActivityTaskCanceledRequest) (*RespondActivityTaskCanceledResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCanceled not implemented")
}
func (UnimplementedHistoryAPIServer) RecordActivityTaskHeartbeat(context.Context, *RecordActivityTaskHeartbeatRequest) (*RecordActivityTaskHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordActivityTaskHeartbeat not implemented")
}
func (UnimplementedHistoryAPIServer) RequestCancelWorkflowExecution(context.Context, *RequestCancelWorkflowExecutionRequest) (*RequestCancelWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestCancelWorkflowExecution not implemented")
}
func (UnimplementedHistoryAPIServer) RemoveSignalMutableState(context.Context, *RemoveSignalMutableStateRequest) (*RemoveSignalMutableStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveSignalMutableState not implemented")
}
func (UnimplementedHistoryAPIServer) ScheduleDecisionTask(context.Context, *ScheduleDecisionTaskRequest) (*ScheduleDecisionTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScheduleDecisionTask not implemented")
}
func (UnimplementedHistoryAPIServer) RecordChildExecutionCompleted(context.Context, *RecordChildExecutionCompletedRequest) (*RecordChildExecutionCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordChildExecutionCompleted not implemented")
}
func (UnimplementedHistoryAPIServer) ReplicateEventsV2(context.Context, *ReplicateEventsV2Request) (*ReplicateEventsV2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplicateEventsV2 not implemented")
}
func (UnimplementedHistoryAPIServer) SyncShardStatus(context.Context, *SyncShardStatusRequest) (*SyncShardStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncShardStatus not implemented")
}
func (UnimplementedHistoryAPIServer) SyncActivity(context.Context, *SyncActivityRequest) (*SyncActivityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncActivity not implemented")
}
func (UnimplementedHistoryAPIServer) DescribeMutableState(context.Context, *DescribeMutableStateRequest) (*DescribeMutableStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeMutableState not implemented")
}
func (UnimplementedHistoryAPIServer) DescribeHistoryHost(context.Context, *DescribeHistoryHostRequest) (*DescribeHistoryHostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeHistoryHost not implemented")
}
func (UnimplementedHistoryAPIServer) CloseShard(context.Context, *CloseShardRequest) (*CloseShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseShard not implemented")
}
func (UnimplementedHistoryAPIServer) RemoveTask(context.Context, *RemoveTaskRequest) (*RemoveTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveTask not implemented")
}
func (UnimplementedHistoryAPIServer) ResetQueue(context.Context, *ResetQueueRequest) (*ResetQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetQueue not implemented")
}
func (UnimplementedHistoryAPIServer) DescribeQueue(context.Context, *DescribeQueueRequest) (*DescribeQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeQueue not implemented")
}
func (UnimplementedHistoryAPIServer) GetReplicationMessages(context.Context, *GetReplicationMessagesRequest) (*GetReplicationMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReplicationMessages not implemented")
}
func (UnimplementedHistoryAPIServer) GetDLQReplicationMessages(context.Context, *GetDLQReplicationMessagesRequest) (*GetDLQReplicationMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDLQReplicationMessages not implemented")
}
func (UnimplementedHistoryAPIServer) ReapplyEvents(context.Context, *ReapplyEventsRequest) (*ReapplyEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReapplyEvents not implemented")
}
func (UnimplementedHistoryAPIServer) RefreshWorkflowTasks(context.Context, *RefreshWorkflowTasksRequest) (*RefreshWorkflowTasksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshWorkflowTasks not implemented")
}
func (UnimplementedHistoryAPIServer) ReadDLQMessages(context.Context, *ReadDLQMessagesRequest) (*ReadDLQMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadDLQMessages not implemented")
}
func (UnimplementedHistoryAPIServer) PurgeDLQMessages(context.Context, *PurgeDLQMessagesRequest) (*PurgeDLQMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PurgeDLQMessages not implemented")
}
func (UnimplementedHistoryAPIServer) MergeDLQMessages(context.Context, *MergeDLQMessagesRequest) (*MergeDLQMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MergeDLQMessages not implemented")
}
func (UnimplementedHistoryAPIServer) NotifyFailoverMarkers(context.Context, *NotifyFailoverMarkersRequest) (*NotifyFailoverMarkersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyFailoverMarkers not implemented")
}
func (UnimplementedHistoryAPIServer) mustEmbedUnimplementedHistoryAPIServer() {}

// UnsafeHistoryAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HistoryAPIServer will
// result in compilation errors.
type UnsafeHistoryAPIServer interface {
	mustEmbedUnimplementedHistoryAPIServer()
}

func RegisterHistoryAPIServer(s grpc.ServiceRegistrar, srv HistoryAPIServer) {
	s.RegisterService(&HistoryAPI_ServiceDesc, srv)
}

func _HistoryAPI_StartWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).StartWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/StartWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).StartWorkflowExecution(ctx, req.(*StartWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_SignalWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignalWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).SignalWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/SignalWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).SignalWorkflowExecution(ctx, req.(*SignalWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_SignalWithStartWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignalWithStartWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).SignalWithStartWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/SignalWithStartWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).SignalWithStartWorkflowExecution(ctx, req.(*SignalWithStartWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_ResetWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).ResetWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/ResetWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).ResetWorkflowExecution(ctx, req.(*ResetWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_TerminateWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).TerminateWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/TerminateWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).TerminateWorkflowExecution(ctx, req.(*TerminateWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_DescribeWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).DescribeWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/DescribeWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).DescribeWorkflowExecution(ctx, req.(*DescribeWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_QueryWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).QueryWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/QueryWorkflow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).QueryWorkflow(ctx, req.(*QueryWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_ResetStickyTaskList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetStickyTaskListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).ResetStickyTaskList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/ResetStickyTaskList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).ResetStickyTaskList(ctx, req.(*ResetStickyTaskListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_GetMutableState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMutableStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).GetMutableState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/GetMutableState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).GetMutableState(ctx, req.(*GetMutableStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_PollMutableState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PollMutableStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).PollMutableState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/PollMutableState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).PollMutableState(ctx, req.(*PollMutableStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_RecordDecisionTaskStarted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordDecisionTaskStartedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).RecordDecisionTaskStarted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/RecordDecisionTaskStarted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).RecordDecisionTaskStarted(ctx, req.(*RecordDecisionTaskStartedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_RespondDecisionTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondDecisionTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).RespondDecisionTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/RespondDecisionTaskCompleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).RespondDecisionTaskCompleted(ctx, req.(*RespondDecisionTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_RespondDecisionTaskFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondDecisionTaskFailedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).RespondDecisionTaskFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/RespondDecisionTaskFailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).RespondDecisionTaskFailed(ctx, req.(*RespondDecisionTaskFailedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_RecordActivityTaskStarted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordActivityTaskStartedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).RecordActivityTaskStarted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/RecordActivityTaskStarted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).RecordActivityTaskStarted(ctx, req.(*RecordActivityTaskStartedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_RespondActivityTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).RespondActivityTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/RespondActivityTaskCompleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).RespondActivityTaskCompleted(ctx, req.(*RespondActivityTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_RespondActivityTaskFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskFailedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).RespondActivityTaskFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/RespondActivityTaskFailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).RespondActivityTaskFailed(ctx, req.(*RespondActivityTaskFailedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_RespondActivityTaskCanceled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCanceledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).RespondActivityTaskCanceled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/RespondActivityTaskCanceled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).RespondActivityTaskCanceled(ctx, req.(*RespondActivityTaskCanceledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_RecordActivityTaskHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordActivityTaskHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).RecordActivityTaskHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/RecordActivityTaskHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).RecordActivityTaskHeartbeat(ctx, req.(*RecordActivityTaskHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_RequestCancelWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestCancelWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).RequestCancelWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/RequestCancelWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).RequestCancelWorkflowExecution(ctx, req.(*RequestCancelWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_RemoveSignalMutableState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveSignalMutableStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).RemoveSignalMutableState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/RemoveSignalMutableState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).RemoveSignalMutableState(ctx, req.(*RemoveSignalMutableStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_ScheduleDecisionTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleDecisionTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).ScheduleDecisionTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/ScheduleDecisionTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).ScheduleDecisionTask(ctx, req.(*ScheduleDecisionTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_RecordChildExecutionCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordChildExecutionCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).RecordChildExecutionCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/RecordChildExecutionCompleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).RecordChildExecutionCompleted(ctx, req.(*RecordChildExecutionCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_ReplicateEventsV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicateEventsV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).ReplicateEventsV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/ReplicateEventsV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).ReplicateEventsV2(ctx, req.(*ReplicateEventsV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_SyncShardStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncShardStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).SyncShardStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/SyncShardStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).SyncShardStatus(ctx, req.(*SyncShardStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_SyncActivity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncActivityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).SyncActivity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/SyncActivity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).SyncActivity(ctx, req.(*SyncActivityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_DescribeMutableState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeMutableStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).DescribeMutableState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/DescribeMutableState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).DescribeMutableState(ctx, req.(*DescribeMutableStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_DescribeHistoryHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeHistoryHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).DescribeHistoryHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/DescribeHistoryHost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).DescribeHistoryHost(ctx, req.(*DescribeHistoryHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_CloseShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).CloseShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/CloseShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).CloseShard(ctx, req.(*CloseShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_RemoveTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).RemoveTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/RemoveTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).RemoveTask(ctx, req.(*RemoveTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_ResetQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).ResetQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/ResetQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).ResetQueue(ctx, req.(*ResetQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_DescribeQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).DescribeQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/DescribeQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).DescribeQueue(ctx, req.(*DescribeQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_GetReplicationMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReplicationMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).GetReplicationMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/GetReplicationMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).GetReplicationMessages(ctx, req.(*GetReplicationMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_GetDLQReplicationMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDLQReplicationMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).GetDLQReplicationMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/GetDLQReplicationMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).GetDLQReplicationMessages(ctx, req.(*GetDLQReplicationMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_ReapplyEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReapplyEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).ReapplyEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/ReapplyEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).ReapplyEvents(ctx, req.(*ReapplyEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_RefreshWorkflowTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshWorkflowTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).RefreshWorkflowTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/RefreshWorkflowTasks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).RefreshWorkflowTasks(ctx, req.(*RefreshWorkflowTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_ReadDLQMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadDLQMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).ReadDLQMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/ReadDLQMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).ReadDLQMessages(ctx, req.(*ReadDLQMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_PurgeDLQMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PurgeDLQMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).PurgeDLQMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/PurgeDLQMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).PurgeDLQMessages(ctx, req.(*PurgeDLQMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_MergeDLQMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MergeDLQMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).MergeDLQMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/MergeDLQMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).MergeDLQMessages(ctx, req.(*MergeDLQMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryAPI_NotifyFailoverMarkers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyFailoverMarkersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryAPIServer).NotifyFailoverMarkers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.history.v1.HistoryAPI/NotifyFailoverMarkers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryAPIServer).NotifyFailoverMarkers(ctx, req.(*NotifyFailoverMarkersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HistoryAPI_ServiceDesc is the grpc.ServiceDesc for HistoryAPI service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HistoryAPI_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "uber.cadence.history.v1.HistoryAPI",
	HandlerType: (*HistoryAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartWorkflowExecution",
			Handler:    _HistoryAPI_StartWorkflowExecution_Handler,
		},
		{
			MethodName: "SignalWorkflowExecution",
			Handler:    _HistoryAPI_SignalWorkflowExecution_Handler,
		},
		{
			MethodName: "SignalWithStartWorkflowExecution",
			Handler:    _HistoryAPI_SignalWithStartWorkflowExecution_Handler,
		},
		{
			MethodName: "ResetWorkflowExecution",
			Handler:    _HistoryAPI_ResetWorkflowExecution_Handler,
		},
		{
			MethodName: "TerminateWorkflowExecution",
			Handler:    _HistoryAPI_TerminateWorkflowExecution_Handler,
		},
		{
			MethodName: "DescribeWorkflowExecution",
			Handler:    _HistoryAPI_DescribeWorkflowExecution_Handler,
		},
		{
			MethodName: "QueryWorkflow",
			Handler:    _HistoryAPI_QueryWorkflow_Handler,
		},
		{
			MethodName: "ResetStickyTaskList",
			Handler:    _HistoryAPI_ResetStickyTaskList_Handler,
		},
		{
			MethodName: "GetMutableState",
			Handler:    _HistoryAPI_GetMutableState_Handler,
		},
		{
			MethodName: "PollMutableState",
			Handler:    _HistoryAPI_PollMutableState_Handler,
		},
		{
			MethodName: "RecordDecisionTaskStarted",
			Handler:    _HistoryAPI_RecordDecisionTaskStarted_Handler,
		},
		{
			MethodName: "RespondDecisionTaskCompleted",
			Handler:    _HistoryAPI_RespondDecisionTaskCompleted_Handler,
		},
		{
			MethodName: "RespondDecisionTaskFailed",
			Handler:    _HistoryAPI_RespondDecisionTaskFailed_Handler,
		},
		{
			MethodName: "RecordActivityTaskStarted",
			Handler:    _HistoryAPI_RecordActivityTaskStarted_Handler,
		},
		{
			MethodName: "RespondActivityTaskCompleted",
			Handler:    _HistoryAPI_RespondActivityTaskCompleted_Handler,
		},
		{
			MethodName: "RespondActivityTaskFailed",
			Handler:    _HistoryAPI_RespondActivityTaskFailed_Handler,
		},
		{
			MethodName: "RespondActivityTaskCanceled",
			Handler:    _HistoryAPI_RespondActivityTaskCanceled_Handler,
		},
		{
			MethodName: "RecordActivityTaskHeartbeat",
			Handler:    _HistoryAPI_RecordActivityTaskHeartbeat_Handler,
		},
		{
			MethodName: "RequestCancelWorkflowExecution",
			Handler:    _HistoryAPI_RequestCancelWorkflowExecution_Handler,
		},
		{
			MethodName: "RemoveSignalMutableState",
			Handler:    _HistoryAPI_RemoveSignalMutableState_Handler,
		},
		{
			MethodName: "ScheduleDecisionTask",
			Handler:    _HistoryAPI_ScheduleDecisionTask_Handler,
		},
		{
			MethodName: "RecordChildExecutionCompleted",
			Handler:    _HistoryAPI_RecordChildExecutionCompleted_Handler,
		},
		{
			MethodName: "ReplicateEventsV2",
			Handler:    _HistoryAPI_ReplicateEventsV2_Handler,
		},
		{
			MethodName: "SyncShardStatus",
			Handler:    _HistoryAPI_SyncShardStatus_Handler,
		},
		{
			MethodName: "SyncActivity",
			Handler:    _HistoryAPI_SyncActivity_Handler,
		},
		{
			MethodName: "DescribeMutableState",
			Handler:    _HistoryAPI_DescribeMutableState_Handler,
		},
		{
			MethodName: "DescribeHistoryHost",
			Handler:    _HistoryAPI_DescribeHistoryHost_Handler,
		},
		{
			MethodName: "CloseShard",
			Handler:    _HistoryAPI_CloseShard_Handler,
		},
		{
			MethodName: "RemoveTask",
			Handler:    _HistoryAPI_RemoveTask_Handler,
		},
		{
			MethodName: "ResetQueue",
			Handler:    _HistoryAPI_ResetQueue_Handler,
		},
		{
			MethodName: "DescribeQueue",
			Handler:    _HistoryAPI_DescribeQueue_Handler,
		},
		{
			MethodName: "GetReplicationMessages",
			Handler:    _HistoryAPI_GetReplicationMessages_Handler,
		},
		{
			MethodName: "GetDLQReplicationMessages",
			Handler:    _HistoryAPI_GetDLQReplicationMessages_Handler,
		},
		{
			MethodName: "ReapplyEvents",
			Handler:    _HistoryAPI_ReapplyEvents_Handler,
		},
		{
			MethodName: "RefreshWorkflowTasks",
			Handler:    _HistoryAPI_RefreshWorkflowTasks_Handler,
		},
		{
			MethodName: "ReadDLQMessages",
			Handler:    _HistoryAPI_ReadDLQMessages_Handler,
		},
		{
			MethodName: "PurgeDLQMessages",
			Handler:    _HistoryAPI_PurgeDLQMessages_Handler,
		},
		{
			MethodName: "MergeDLQMessages",
			Handler:    _HistoryAPI_MergeDLQMessages_Handler,
		},
		{
			MethodName: "NotifyFailoverMarkers",
			Handler:    _HistoryAPI_NotifyFailoverMarkers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "uber/cadence/history/v1/service.proto",
}
