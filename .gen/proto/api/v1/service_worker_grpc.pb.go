// The MIT License (MIT)

// Copyright (c) 2017-2020 Uber Technologies Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package apiv1

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// WorkerAPIClient is the client API for WorkerAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkerAPIClient interface {
	// PollForDecisionTask is called by application worker to process DecisionTask from a specific taskList.
	// A DecisionTask is dispatched to callers for active workflow executions, with pending decisions.
	// Application is then expected to call 'RespondDecisionTaskCompleted' API when it is done processing the DecisionTask.
	// It will also create a 'DecisionTaskStarted' event in the history for that session before handing off DecisionTask to
	// application worker.
	PollForDecisionTask(ctx context.Context, in *PollForDecisionTaskRequest, opts ...grpc.CallOption) (*PollForDecisionTaskResponse, error)
	// RespondDecisionTaskCompleted is called by application worker to complete a DecisionTask handed as a result of
	// 'PollForDecisionTask' API call.  Completing a DecisionTask will result in new events for the workflow execution and
	// potentially new ActivityTask being created for corresponding decisions.  It will also create a DecisionTaskCompleted
	// event in the history for that session.  Use the 'taskToken' provided as response of PollForDecisionTask API call
	// for completing the DecisionTask.
	// The response could contain a new decision task if there is one or if the request asking for one.
	RespondDecisionTaskCompleted(ctx context.Context, in *RespondDecisionTaskCompletedRequest, opts ...grpc.CallOption) (*RespondDecisionTaskCompletedResponse, error)
	// RespondDecisionTaskFailed is called by application worker to indicate failure.  This results in
	// DecisionTaskFailedEvent written to the history and a new DecisionTask created.  This API can be used by client to
	// either clear sticky tasklist or report any panics during DecisionTask processing.  Cadence will only append first
	// DecisionTaskFailed event to the history of workflow execution for consecutive failures.
	RespondDecisionTaskFailed(ctx context.Context, in *RespondDecisionTaskFailedRequest, opts ...grpc.CallOption) (*RespondDecisionTaskFailedResponse, error)
	// PollForActivityTask is called by application worker to process ActivityTask from a specific taskList.  ActivityTask
	// is dispatched to callers whenever a ScheduleTask decision is made for a workflow execution.
	// Application is expected to call 'RespondActivityTaskCompleted' or 'RespondActivityTaskFailed' once it is done
	// processing the task.
	// Application also needs to call 'RecordActivityTaskHeartbeat' API within 'heartbeatTimeoutSeconds' interval to
	// prevent the task from getting timed out.  An event 'ActivityTaskStarted' event is also written to workflow execution
	// history before the ActivityTask is dispatched to application worker.
	PollForActivityTask(ctx context.Context, in *PollForActivityTaskRequest, opts ...grpc.CallOption) (*PollForActivityTaskResponse, error)
	// RespondActivityTaskCompleted is called by application worker when it is done processing an ActivityTask.  It will
	// result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
	// created for the workflow so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskCompleted(ctx context.Context, in *RespondActivityTaskCompletedRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedResponse, error)
	// RespondActivityTaskCompletedByID is called by application worker when it is done processing an ActivityTask.
	// It will result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
	// created for the workflow so new decisions could be made.  Similar to RespondActivityTaskCompleted but use Domain,
	// WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
	// if the these IDs are not valid anymore due to activity timeout.
	RespondActivityTaskCompletedByID(ctx context.Context, in *RespondActivityTaskCompletedByIDRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedByIDResponse, error)
	// RespondActivityTaskFailed is called by application worker when it is done processing an ActivityTask.  It will
	// result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskFailed(ctx context.Context, in *RespondActivityTaskFailedRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedResponse, error)
	// RespondActivityTaskFailedByID is called by application worker when it is done processing an ActivityTask.
	// It will result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Similar to RespondActivityTaskFailed but use
	// Domain, WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
	// if the these IDs are not valid anymore due to activity timeout.
	RespondActivityTaskFailedByID(ctx context.Context, in *RespondActivityTaskFailedByIDRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedByIDResponse, error)
	// RespondActivityTaskCanceled is called by application worker when it is successfully canceled an ActivityTask.
	// It will result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskCanceled(ctx context.Context, in *RespondActivityTaskCanceledRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledResponse, error)
	// RespondActivityTaskCanceledByID is called by application worker when it is successfully canceled an ActivityTask.
	// It will result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Similar to RespondActivityTaskCanceled but use
	// Domain, WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
	// if the these IDs are not valid anymore due to activity timeout.
	RespondActivityTaskCanceledByID(ctx context.Context, in *RespondActivityTaskCanceledByIDRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledByIDResponse, error)
	// RecordActivityTaskHeartbeat is called by application worker while it is processing an ActivityTask.  If worker fails
	// to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timedout and
	// 'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
	// fail with 'EntityNotExistsError' in such situations.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for heartbeating.
	RecordActivityTaskHeartbeat(ctx context.Context, in *RecordActivityTaskHeartbeatRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatResponse, error)
	// RecordActivityTaskHeartbeatByID is called by application worker while it is processing an ActivityTask.  If worker
	// fails to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as
	// timed out and 'ActivityTaskTimedOut' event will be written to the workflow history.
	// Calling 'RecordActivityTaskHeartbeatByID' will fail with 'EntityNotExistsError' in such situations.  Instead of
	// using 'taskToken' like in RecordActivityTaskHeartbeat, use Domain, WorkflowID and ActivityID.
	RecordActivityTaskHeartbeatByID(ctx context.Context, in *RecordActivityTaskHeartbeatByIDRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatByIDResponse, error)
	// RespondQueryTaskCompleted is called by application worker to complete a QueryTask (which is a DecisionTask for query)
	// as a result of 'PollForDecisionTask' API call. Completing a QueryTask will unblock the client call to 'QueryWorkflow'
	// API and return the query result to client as a response to 'QueryWorkflow' API call.
	RespondQueryTaskCompleted(ctx context.Context, in *RespondQueryTaskCompletedRequest, opts ...grpc.CallOption) (*RespondQueryTaskCompletedResponse, error)
	// RequestCancelWorkflowExecution is called by application worker when it wants to request cancellation of a workflow
	// instance. It will result in a new 'WorkflowExecutionCancelRequested' event being written to the workflow history
	// and a new DecisionTask created for the workflow instance so new decisions could be made. It fails with
	// 'EntityNotExistsError' if the workflow is not valid anymore due to completion or doesn't exist.
	RequestCancelWorkflowExecution(ctx context.Context, in *RequestCancelWorkflowExecutionRequest, opts ...grpc.CallOption) (*RequestCancelWorkflowExecutionResponse, error)
}

type workerAPIClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkerAPIClient(cc grpc.ClientConnInterface) WorkerAPIClient {
	return &workerAPIClient{cc}
}

func (c *workerAPIClient) PollForDecisionTask(ctx context.Context, in *PollForDecisionTaskRequest, opts ...grpc.CallOption) (*PollForDecisionTaskResponse, error) {
	out := new(PollForDecisionTaskResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.api.v1.WorkerAPI/PollForDecisionTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerAPIClient) RespondDecisionTaskCompleted(ctx context.Context, in *RespondDecisionTaskCompletedRequest, opts ...grpc.CallOption) (*RespondDecisionTaskCompletedResponse, error) {
	out := new(RespondDecisionTaskCompletedResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.api.v1.WorkerAPI/RespondDecisionTaskCompleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerAPIClient) RespondDecisionTaskFailed(ctx context.Context, in *RespondDecisionTaskFailedRequest, opts ...grpc.CallOption) (*RespondDecisionTaskFailedResponse, error) {
	out := new(RespondDecisionTaskFailedResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.api.v1.WorkerAPI/RespondDecisionTaskFailed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerAPIClient) PollForActivityTask(ctx context.Context, in *PollForActivityTaskRequest, opts ...grpc.CallOption) (*PollForActivityTaskResponse, error) {
	out := new(PollForActivityTaskResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.api.v1.WorkerAPI/PollForActivityTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerAPIClient) RespondActivityTaskCompleted(ctx context.Context, in *RespondActivityTaskCompletedRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedResponse, error) {
	out := new(RespondActivityTaskCompletedResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskCompleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerAPIClient) RespondActivityTaskCompletedByID(ctx context.Context, in *RespondActivityTaskCompletedByIDRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedByIDResponse, error) {
	out := new(RespondActivityTaskCompletedByIDResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskCompletedByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerAPIClient) RespondActivityTaskFailed(ctx context.Context, in *RespondActivityTaskFailedRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedResponse, error) {
	out := new(RespondActivityTaskFailedResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskFailed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerAPIClient) RespondActivityTaskFailedByID(ctx context.Context, in *RespondActivityTaskFailedByIDRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedByIDResponse, error) {
	out := new(RespondActivityTaskFailedByIDResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskFailedByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerAPIClient) RespondActivityTaskCanceled(ctx context.Context, in *RespondActivityTaskCanceledRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledResponse, error) {
	out := new(RespondActivityTaskCanceledResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskCanceled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerAPIClient) RespondActivityTaskCanceledByID(ctx context.Context, in *RespondActivityTaskCanceledByIDRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledByIDResponse, error) {
	out := new(RespondActivityTaskCanceledByIDResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskCanceledByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerAPIClient) RecordActivityTaskHeartbeat(ctx context.Context, in *RecordActivityTaskHeartbeatRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatResponse, error) {
	out := new(RecordActivityTaskHeartbeatResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.api.v1.WorkerAPI/RecordActivityTaskHeartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerAPIClient) RecordActivityTaskHeartbeatByID(ctx context.Context, in *RecordActivityTaskHeartbeatByIDRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatByIDResponse, error) {
	out := new(RecordActivityTaskHeartbeatByIDResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.api.v1.WorkerAPI/RecordActivityTaskHeartbeatByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerAPIClient) RespondQueryTaskCompleted(ctx context.Context, in *RespondQueryTaskCompletedRequest, opts ...grpc.CallOption) (*RespondQueryTaskCompletedResponse, error) {
	out := new(RespondQueryTaskCompletedResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.api.v1.WorkerAPI/RespondQueryTaskCompleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerAPIClient) RequestCancelWorkflowExecution(ctx context.Context, in *RequestCancelWorkflowExecutionRequest, opts ...grpc.CallOption) (*RequestCancelWorkflowExecutionResponse, error) {
	out := new(RequestCancelWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/uber.cadence.api.v1.WorkerAPI/RequestCancelWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerAPIServer is the server API for WorkerAPI service.
// All implementations must embed UnimplementedWorkerAPIServer
// for forward compatibility
type WorkerAPIServer interface {
	// PollForDecisionTask is called by application worker to process DecisionTask from a specific taskList.
	// A DecisionTask is dispatched to callers for active workflow executions, with pending decisions.
	// Application is then expected to call 'RespondDecisionTaskCompleted' API when it is done processing the DecisionTask.
	// It will also create a 'DecisionTaskStarted' event in the history for that session before handing off DecisionTask to
	// application worker.
	PollForDecisionTask(context.Context, *PollForDecisionTaskRequest) (*PollForDecisionTaskResponse, error)
	// RespondDecisionTaskCompleted is called by application worker to complete a DecisionTask handed as a result of
	// 'PollForDecisionTask' API call.  Completing a DecisionTask will result in new events for the workflow execution and
	// potentially new ActivityTask being created for corresponding decisions.  It will also create a DecisionTaskCompleted
	// event in the history for that session.  Use the 'taskToken' provided as response of PollForDecisionTask API call
	// for completing the DecisionTask.
	// The response could contain a new decision task if there is one or if the request asking for one.
	RespondDecisionTaskCompleted(context.Context, *RespondDecisionTaskCompletedRequest) (*RespondDecisionTaskCompletedResponse, error)
	// RespondDecisionTaskFailed is called by application worker to indicate failure.  This results in
	// DecisionTaskFailedEvent written to the history and a new DecisionTask created.  This API can be used by client to
	// either clear sticky tasklist or report any panics during DecisionTask processing.  Cadence will only append first
	// DecisionTaskFailed event to the history of workflow execution for consecutive failures.
	RespondDecisionTaskFailed(context.Context, *RespondDecisionTaskFailedRequest) (*RespondDecisionTaskFailedResponse, error)
	// PollForActivityTask is called by application worker to process ActivityTask from a specific taskList.  ActivityTask
	// is dispatched to callers whenever a ScheduleTask decision is made for a workflow execution.
	// Application is expected to call 'RespondActivityTaskCompleted' or 'RespondActivityTaskFailed' once it is done
	// processing the task.
	// Application also needs to call 'RecordActivityTaskHeartbeat' API within 'heartbeatTimeoutSeconds' interval to
	// prevent the task from getting timed out.  An event 'ActivityTaskStarted' event is also written to workflow execution
	// history before the ActivityTask is dispatched to application worker.
	PollForActivityTask(context.Context, *PollForActivityTaskRequest) (*PollForActivityTaskResponse, error)
	// RespondActivityTaskCompleted is called by application worker when it is done processing an ActivityTask.  It will
	// result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
	// created for the workflow so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskCompleted(context.Context, *RespondActivityTaskCompletedRequest) (*RespondActivityTaskCompletedResponse, error)
	// RespondActivityTaskCompletedByID is called by application worker when it is done processing an ActivityTask.
	// It will result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
	// created for the workflow so new decisions could be made.  Similar to RespondActivityTaskCompleted but use Domain,
	// WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
	// if the these IDs are not valid anymore due to activity timeout.
	RespondActivityTaskCompletedByID(context.Context, *RespondActivityTaskCompletedByIDRequest) (*RespondActivityTaskCompletedByIDResponse, error)
	// RespondActivityTaskFailed is called by application worker when it is done processing an ActivityTask.  It will
	// result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskFailed(context.Context, *RespondActivityTaskFailedRequest) (*RespondActivityTaskFailedResponse, error)
	// RespondActivityTaskFailedByID is called by application worker when it is done processing an ActivityTask.
	// It will result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Similar to RespondActivityTaskFailed but use
	// Domain, WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
	// if the these IDs are not valid anymore due to activity timeout.
	RespondActivityTaskFailedByID(context.Context, *RespondActivityTaskFailedByIDRequest) (*RespondActivityTaskFailedByIDResponse, error)
	// RespondActivityTaskCanceled is called by application worker when it is successfully canceled an ActivityTask.
	// It will result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskCanceled(context.Context, *RespondActivityTaskCanceledRequest) (*RespondActivityTaskCanceledResponse, error)
	// RespondActivityTaskCanceledByID is called by application worker when it is successfully canceled an ActivityTask.
	// It will result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Similar to RespondActivityTaskCanceled but use
	// Domain, WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
	// if the these IDs are not valid anymore due to activity timeout.
	RespondActivityTaskCanceledByID(context.Context, *RespondActivityTaskCanceledByIDRequest) (*RespondActivityTaskCanceledByIDResponse, error)
	// RecordActivityTaskHeartbeat is called by application worker while it is processing an ActivityTask.  If worker fails
	// to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timedout and
	// 'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
	// fail with 'EntityNotExistsError' in such situations.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for heartbeating.
	RecordActivityTaskHeartbeat(context.Context, *RecordActivityTaskHeartbeatRequest) (*RecordActivityTaskHeartbeatResponse, error)
	// RecordActivityTaskHeartbeatByID is called by application worker while it is processing an ActivityTask.  If worker
	// fails to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as
	// timed out and 'ActivityTaskTimedOut' event will be written to the workflow history.
	// Calling 'RecordActivityTaskHeartbeatByID' will fail with 'EntityNotExistsError' in such situations.  Instead of
	// using 'taskToken' like in RecordActivityTaskHeartbeat, use Domain, WorkflowID and ActivityID.
	RecordActivityTaskHeartbeatByID(context.Context, *RecordActivityTaskHeartbeatByIDRequest) (*RecordActivityTaskHeartbeatByIDResponse, error)
	// RespondQueryTaskCompleted is called by application worker to complete a QueryTask (which is a DecisionTask for query)
	// as a result of 'PollForDecisionTask' API call. Completing a QueryTask will unblock the client call to 'QueryWorkflow'
	// API and return the query result to client as a response to 'QueryWorkflow' API call.
	RespondQueryTaskCompleted(context.Context, *RespondQueryTaskCompletedRequest) (*RespondQueryTaskCompletedResponse, error)
	// RequestCancelWorkflowExecution is called by application worker when it wants to request cancellation of a workflow
	// instance. It will result in a new 'WorkflowExecutionCancelRequested' event being written to the workflow history
	// and a new DecisionTask created for the workflow instance so new decisions could be made. It fails with
	// 'EntityNotExistsError' if the workflow is not valid anymore due to completion or doesn't exist.
	RequestCancelWorkflowExecution(context.Context, *RequestCancelWorkflowExecutionRequest) (*RequestCancelWorkflowExecutionResponse, error)
	mustEmbedUnimplementedWorkerAPIServer()
}

// UnimplementedWorkerAPIServer must be embedded to have forward compatible implementations.
type UnimplementedWorkerAPIServer struct {
}

func (UnimplementedWorkerAPIServer) PollForDecisionTask(context.Context, *PollForDecisionTaskRequest) (*PollForDecisionTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollForDecisionTask not implemented")
}
func (UnimplementedWorkerAPIServer) RespondDecisionTaskCompleted(context.Context, *RespondDecisionTaskCompletedRequest) (*RespondDecisionTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondDecisionTaskCompleted not implemented")
}
func (UnimplementedWorkerAPIServer) RespondDecisionTaskFailed(context.Context, *RespondDecisionTaskFailedRequest) (*RespondDecisionTaskFailedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondDecisionTaskFailed not implemented")
}
func (UnimplementedWorkerAPIServer) PollForActivityTask(context.Context, *PollForActivityTaskRequest) (*PollForActivityTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollForActivityTask not implemented")
}
func (UnimplementedWorkerAPIServer) RespondActivityTaskCompleted(context.Context, *RespondActivityTaskCompletedRequest) (*RespondActivityTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCompleted not implemented")
}
func (UnimplementedWorkerAPIServer) RespondActivityTaskCompletedByID(context.Context, *RespondActivityTaskCompletedByIDRequest) (*RespondActivityTaskCompletedByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCompletedByID not implemented")
}
func (UnimplementedWorkerAPIServer) RespondActivityTaskFailed(context.Context, *RespondActivityTaskFailedRequest) (*RespondActivityTaskFailedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskFailed not implemented")
}
func (UnimplementedWorkerAPIServer) RespondActivityTaskFailedByID(context.Context, *RespondActivityTaskFailedByIDRequest) (*RespondActivityTaskFailedByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskFailedByID not implemented")
}
func (UnimplementedWorkerAPIServer) RespondActivityTaskCanceled(context.Context, *RespondActivityTaskCanceledRequest) (*RespondActivityTaskCanceledResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCanceled not implemented")
}
func (UnimplementedWorkerAPIServer) RespondActivityTaskCanceledByID(context.Context, *RespondActivityTaskCanceledByIDRequest) (*RespondActivityTaskCanceledByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCanceledByID not implemented")
}
func (UnimplementedWorkerAPIServer) RecordActivityTaskHeartbeat(context.Context, *RecordActivityTaskHeartbeatRequest) (*RecordActivityTaskHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordActivityTaskHeartbeat not implemented")
}
func (UnimplementedWorkerAPIServer) RecordActivityTaskHeartbeatByID(context.Context, *RecordActivityTaskHeartbeatByIDRequest) (*RecordActivityTaskHeartbeatByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordActivityTaskHeartbeatByID not implemented")
}
func (UnimplementedWorkerAPIServer) RespondQueryTaskCompleted(context.Context, *RespondQueryTaskCompletedRequest) (*RespondQueryTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondQueryTaskCompleted not implemented")
}
func (UnimplementedWorkerAPIServer) RequestCancelWorkflowExecution(context.Context, *RequestCancelWorkflowExecutionRequest) (*RequestCancelWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestCancelWorkflowExecution not implemented")
}
func (UnimplementedWorkerAPIServer) mustEmbedUnimplementedWorkerAPIServer() {}

// UnsafeWorkerAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkerAPIServer will
// result in compilation errors.
type UnsafeWorkerAPIServer interface {
	mustEmbedUnimplementedWorkerAPIServer()
}

func RegisterWorkerAPIServer(s grpc.ServiceRegistrar, srv WorkerAPIServer) {
	s.RegisterService(&WorkerAPI_ServiceDesc, srv)
}

func _WorkerAPI_PollForDecisionTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PollForDecisionTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerAPIServer).PollForDecisionTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.api.v1.WorkerAPI/PollForDecisionTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerAPIServer).PollForDecisionTask(ctx, req.(*PollForDecisionTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerAPI_RespondDecisionTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondDecisionTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerAPIServer).RespondDecisionTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.api.v1.WorkerAPI/RespondDecisionTaskCompleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerAPIServer).RespondDecisionTaskCompleted(ctx, req.(*RespondDecisionTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerAPI_RespondDecisionTaskFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondDecisionTaskFailedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerAPIServer).RespondDecisionTaskFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.api.v1.WorkerAPI/RespondDecisionTaskFailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerAPIServer).RespondDecisionTaskFailed(ctx, req.(*RespondDecisionTaskFailedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerAPI_PollForActivityTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PollForActivityTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerAPIServer).PollForActivityTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.api.v1.WorkerAPI/PollForActivityTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerAPIServer).PollForActivityTask(ctx, req.(*PollForActivityTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerAPI_RespondActivityTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerAPIServer).RespondActivityTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskCompleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerAPIServer).RespondActivityTaskCompleted(ctx, req.(*RespondActivityTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerAPI_RespondActivityTaskCompletedByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCompletedByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerAPIServer).RespondActivityTaskCompletedByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskCompletedByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerAPIServer).RespondActivityTaskCompletedByID(ctx, req.(*RespondActivityTaskCompletedByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerAPI_RespondActivityTaskFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskFailedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerAPIServer).RespondActivityTaskFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskFailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerAPIServer).RespondActivityTaskFailed(ctx, req.(*RespondActivityTaskFailedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerAPI_RespondActivityTaskFailedByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskFailedByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerAPIServer).RespondActivityTaskFailedByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskFailedByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerAPIServer).RespondActivityTaskFailedByID(ctx, req.(*RespondActivityTaskFailedByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerAPI_RespondActivityTaskCanceled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCanceledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerAPIServer).RespondActivityTaskCanceled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskCanceled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerAPIServer).RespondActivityTaskCanceled(ctx, req.(*RespondActivityTaskCanceledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerAPI_RespondActivityTaskCanceledByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCanceledByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerAPIServer).RespondActivityTaskCanceledByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskCanceledByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerAPIServer).RespondActivityTaskCanceledByID(ctx, req.(*RespondActivityTaskCanceledByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerAPI_RecordActivityTaskHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordActivityTaskHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerAPIServer).RecordActivityTaskHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.api.v1.WorkerAPI/RecordActivityTaskHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerAPIServer).RecordActivityTaskHeartbeat(ctx, req.(*RecordActivityTaskHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerAPI_RecordActivityTaskHeartbeatByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordActivityTaskHeartbeatByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerAPIServer).RecordActivityTaskHeartbeatByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.api.v1.WorkerAPI/RecordActivityTaskHeartbeatByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerAPIServer).RecordActivityTaskHeartbeatByID(ctx, req.(*RecordActivityTaskHeartbeatByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerAPI_RespondQueryTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondQueryTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerAPIServer).RespondQueryTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.api.v1.WorkerAPI/RespondQueryTaskCompleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerAPIServer).RespondQueryTaskCompleted(ctx, req.(*RespondQueryTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerAPI_RequestCancelWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestCancelWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerAPIServer).RequestCancelWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uber.cadence.api.v1.WorkerAPI/RequestCancelWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerAPIServer).RequestCancelWorkflowExecution(ctx, req.(*RequestCancelWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkerAPI_ServiceDesc is the grpc.ServiceDesc for WorkerAPI service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkerAPI_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "uber.cadence.api.v1.WorkerAPI",
	HandlerType: (*WorkerAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PollForDecisionTask",
			Handler:    _WorkerAPI_PollForDecisionTask_Handler,
		},
		{
			MethodName: "RespondDecisionTaskCompleted",
			Handler:    _WorkerAPI_RespondDecisionTaskCompleted_Handler,
		},
		{
			MethodName: "RespondDecisionTaskFailed",
			Handler:    _WorkerAPI_RespondDecisionTaskFailed_Handler,
		},
		{
			MethodName: "PollForActivityTask",
			Handler:    _WorkerAPI_PollForActivityTask_Handler,
		},
		{
			MethodName: "RespondActivityTaskCompleted",
			Handler:    _WorkerAPI_RespondActivityTaskCompleted_Handler,
		},
		{
			MethodName: "RespondActivityTaskCompletedByID",
			Handler:    _WorkerAPI_RespondActivityTaskCompletedByID_Handler,
		},
		{
			MethodName: "RespondActivityTaskFailed",
			Handler:    _WorkerAPI_RespondActivityTaskFailed_Handler,
		},
		{
			MethodName: "RespondActivityTaskFailedByID",
			Handler:    _WorkerAPI_RespondActivityTaskFailedByID_Handler,
		},
		{
			MethodName: "RespondActivityTaskCanceled",
			Handler:    _WorkerAPI_RespondActivityTaskCanceled_Handler,
		},
		{
			MethodName: "RespondActivityTaskCanceledByID",
			Handler:    _WorkerAPI_RespondActivityTaskCanceledByID_Handler,
		},
		{
			MethodName: "RecordActivityTaskHeartbeat",
			Handler:    _WorkerAPI_RecordActivityTaskHeartbeat_Handler,
		},
		{
			MethodName: "RecordActivityTaskHeartbeatByID",
			Handler:    _WorkerAPI_RecordActivityTaskHeartbeatByID_Handler,
		},
		{
			MethodName: "RespondQueryTaskCompleted",
			Handler:    _WorkerAPI_RespondQueryTaskCompleted_Handler,
		},
		{
			MethodName: "RequestCancelWorkflowExecution",
			Handler:    _WorkerAPI_RequestCancelWorkflowExecution_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "uber/cadence/api/v1/service_worker.proto",
}
